{"title":"Java 并发编程","date":"2023-04-11T20:37:01.000Z","date_formatted":{"ll":"Apr 11, 2023","L":"04/11/2023","MM-DD":"04-11"},"link":"2023/04/11/java-concurrency-programming-1","tags":["java"],"categories":["concurrency-programming"],"updated":"2023-04-13T15:08:34.440Z","content":"<h2 id=\"thread-class\">Thread class<a title=\"#thread-class\" href=\"#thread-class\"></a></h2>\n<p>Java doc 注释</p>\n<blockquote>\n<p>A thread is a thread of execution in a program.<br><br>\nThe Java Virtual Machine allows an application to have multiple threads of execution running concurrently.<br><br>\nEvery thread has a priority.</p>\n</blockquote>\n<p><code>java.lang.Thread</code> 类是 Java 提供的最核心的创建线程的类。</p>\n<h3 id=\"线程的状态\">线程的状态<a title=\"#线程的状态\" href=\"#线程的状态\"></a></h3>\n<ol>\n<li><strong>初始(NEW)</strong>：新创建了一个线程对象，但还没有调用start()方法。</li>\n<li><strong>运行(RUNNABLE)</strong>：Java线程中将就绪（ready）和运行中（running）两种状态笼统的称为“运行”。线程对象创建后，其他线程(比如main线程）调用了该对象的start()方法。该状态的线程位于可运行线程池中，等待被线程调度选中，获取CPU的使用权，此时处于就绪状态（ready）。就绪状态的线程在获得CPU时间片后变为运行中状态（running）。</li>\n<li><strong>阻塞(BLOCKED)</strong>：表示线程阻塞于锁。</li>\n<li><strong>等待(WAITING)</strong>：进入该状态的线程需要等待其他线程做出一些特定动作（通知或中断）。</li>\n<li><strong>超时等待(TIMED_WAITING)</strong>：该状态不同于WAITING，它可以在指定的时间后自行返回。</li>\n<li><strong>终止(TERMINATED)</strong>：表示该线程已经执行完毕。</li>\n</ol>\n<h3 id=\"创建执行线程的方法\">创建执行线程的方法<a title=\"#创建执行线程的方法\" href=\"#创建执行线程的方法\"></a></h3>\n<ul>\n<li>定义实现 <code>java.lang.Runnable</code> 接口（推荐使用），同时通过 <code>java.lang.Thread</code> 的构造函数进行实例化</li>\n<li>定义一个 <code>java.lang.Thread</code> 类的子类，同时重写 <code>run</code> 方法。</li>\n</ul>\n<p>其中特别说明的是通过 Runnable 接口的方式，其中一种是实现 Runnable 接口，适用于执行任务无返回结果的场景，<br>\n一种是实现 Callable 接口，结合 Future 实现，适合于执行任务有返回结果的场景。两个接口都是函数式接口，实现时<br>\n可以通过 Lambda 函数或方法引用来简化代码。</p>\n<h2 id=\"executor-framework\">Executor Framework<a title=\"#executor-framework\" href=\"#executor-framework\"></a></h2>\n<h3 id=\"threadpoolexecutor-class\">ThreadPoolExecutor class<a title=\"#threadpoolexecutor-class\" href=\"#threadpoolexecutor-class\"></a></h3>\n<h4 id=\"执行流程\">执行流程<a title=\"#执行流程\" href=\"#执行流程\"></a></h4>\n<ol>\n<li>判断线程池中核心线程数是否达到 <code>corePoolSize</code>，未达到，创建核心线程执行任务</li>\n<li>若已达 <code>corePoolSize</code>，则判断 <code>workQueue</code> 是否已满，未满，则将新任务添加进 <code>workQueue</code></li>\n<li>若 <code>wokrQueue</code> 已满，则判断线程池中线程数是否已达到 <code>maximumPoolSize</code> ，若未达到，则创建一个非核心线程执行任务</li>\n<li>若已达 <code>maximumPoolSize</code>，则执行线程池的拒绝策略</li>\n</ol>\n<h4 id=\"核心参数\">核心参数<a title=\"#核心参数\" href=\"#核心参数\"></a></h4>\n<ol>\n<li><code>corePoolSize</code>: 核心线程数（常驻线程）</li>\n<li><code>maximumPoolSize</code>：线程池中运行的最大线程数（包括核心线程和非核心线程）</li>\n<li><code>keepAliveTime</code> 线程池中空闲线程（仅适用于非核心线程）所能存活的最长时间</li>\n<li><code>unit</code> 存活时间单位，与 <code>keepAliveTime</code> 搭配使用</li>\n<li><code>workQueue</code> 存放任务的工作阻塞队列</li>\n<li>线程拒绝策略</li>\n</ol>\n<h4 id=\"线程池的拒绝策略\">线程池的拒绝策略<a title=\"#线程池的拒绝策略\" href=\"#线程池的拒绝策略\"></a></h4>\n<ul>\n<li><strong>AbortPolicy</strong>：中止策略，线程池会抛出异常并中止执行此任务（默认）</li>\n<li><strong>CallerRunsPolicy</strong>：把任务交给添加此任务的（main）线程来执行；</li>\n<li><strong>DiscardPolicy</strong>：忽略此任务，忽略最新的一个任务；</li>\n<li><strong>DiscardOldestPolicy</strong>：忽略最早的任务，最先加入队列的任务。</li>\n</ul>\n<h3 id=\"executors-class\">Executors class<a title=\"#executors-class\" href=\"#executors-class\"></a></h3>\n<p>Java 封装了一系列常用的线程池方法。</p>\n<blockquote>\n<p>newFixedThreadPool(int nThreads): 创建一个固定大小的线程池<br>\nnewSingleThreadExecutor()：创建一个单线程化线程池<br>\nnewCachedThreadPool()：创建一个可缓存线程池<br>\nnewScheduledThreadPool()：创建一个支持定时与周期性任务的线程池<br>\nnewWorkStealingPool()：创建一个支持工作窃取的线程池</p>\n</blockquote>\n<h4 id=\"fixedthreadpool：定长线程池\">FixedThreadPool：定长线程池<a title=\"#fixedthreadpool：定长线程池\" href=\"#fixedthreadpool：定长线程池\"></a></h4>\n<p><a href=\"https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/Executors.html\" target=\"_blank\">Java doc</a></p>\n<blockquote>\n<p>Creates a thread pool that reuses a fixed number of threads operating off a shared unbounded queue.</p>\n</blockquote>\n<p>定长线程池可控制线程最大并发数，超出的线程会在队列中等待。</p>\n<p>Warning</p>\n<blockquote>\n<p>Executors.newFixedThreadPool 方法的工作队列的长度是 <code>Integer.MAX_VALUE</code>，可能会造成 OOM 问题。</p>\n</blockquote>\n<h4 id=\"singlethreadexecutor：单线程化线程池\">SingleThreadExecutor：单线程化线程池<a title=\"#singlethreadexecutor：单线程化线程池\" href=\"#singlethreadexecutor：单线程化线程池\"></a></h4>\n<p><a href=\"https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/Executors.html\" target=\"_blank\">Java doc</a></p>\n<blockquote>\n<p>Creates an Executor that uses a single worker thread operating off an unbounded queue.<br>\n(Note however that if this single thread terminates due to a failure during execution prior to shut-down,<br>\na new one will take its place if needed to execute subsequent tasks.)</p>\n</blockquote>\n<p>单线程化线程池只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行。<br>\n工作队列同样是设置 <code>Integer.MAX_VALUE</code>，可能会造成 OOM 问题。</p>\n<h4 id=\"cachedthreadpool：可缓存线程池\">CachedThreadPool：可缓存线程池<a title=\"#cachedthreadpool：可缓存线程池\" href=\"#cachedthreadpool：可缓存线程池\"></a></h4>\n<p><a href=\"https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/Executors.html\" target=\"_blank\">Java doc</a></p>\n<blockquote>\n<p>Creates a thread pool that creates new threads as needed,<br>\nbut will reuse previously constructed threads when they are available.</p>\n</blockquote>\n<p>可缓存线程池会将之前创建的线程在可用时重用它们，从而完成缓存线程。<br>\n其允许的创建线程数量为 Integer.MAX_VALUE，可能会创建大量的线程，从而导致 OOM 。</p>\n<h4 id=\"scheduledthreadpool：支持定时及周期性任务执行的定长线程池\">ScheduledThreadPool：支持定时及周期性任务执行的定长线程池<a title=\"#scheduledthreadpool：支持定时及周期性任务执行的定长线程池\" href=\"#scheduledthreadpool：支持定时及周期性任务执行的定长线程池\"></a></h4>\n<p><a href=\"https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/Executors.html\" target=\"_blank\">Java doc</a></p>\n<blockquote>\n<p>Creates a thread pool that can schedule commands to run after a given delay, or to execute periodically.</p>\n</blockquote>\n<p>创建一个定长线程池，支持定时及周期性任务执行。可以作为延时任务的解决方案之一，比 Timer 要更安全，功能更强大。</p>\n<h4 id=\"workstealingpool：-forkjoinpool-，基于-work-stealing-算法，支持工作窃取\">WorkStealingPool： ForkJoinPool ，基于 work-stealing 算法，支持工作窃取<a title=\"#workstealingpool：-forkjoinpool-，基于-work-stealing-算法，支持工作窃取\" href=\"#workstealingpool：-forkjoinpool-，基于-work-stealing-算法，支持工作窃取\"></a></h4>\n<p><a href=\"https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/Executors.html\" target=\"_blank\">Java doc</a></p>\n<blockquote>\n<p>Creates a work-stealing thread pool using the number of available processors as its target parallelism level.</p>\n</blockquote>\n<p>顾名思义，它是基于 work-stealing 算法的，其中一个任务可以产生其他较小的任务，这些任务被添加到并行处理线程的队列中。<br>\n如果一个线程完成了工作并且无事可做，则可以从另一线程的队列中&quot;窃取&quot;工作。</p>\n<h2 id=\"completablefuture-class\">CompletableFuture class<a title=\"#completablefuture-class\" href=\"#completablefuture-class\"></a></h2>\n<h2 id=\"atomic\">Atomic<a title=\"#atomic\" href=\"#atomic\"></a></h2>\n","next":{"title":"并发编程","link":"2023/04/01/concurrency-programming"},"plink":"https://hadron404.github.io/blog/2023/04/11/java-concurrency-programming-1/","toc":[{"id":"thread-class","title":"Thread class","index":"1","children":[{"id":"线程的状态","title":"线程的状态","index":"1.1"},{"id":"创建执行线程的方法","title":"创建执行线程的方法","index":"1.2"}]},{"id":"executor-framework","title":"Executor Framework","index":"2","children":[{"id":"threadpoolexecutor-class","title":"ThreadPoolExecutor class","index":"2.1"},{"id":"executors-class","title":"Executors class","index":"2.2"}]},{"id":"completablefuture-class","title":"CompletableFuture class","index":"3"},{"id":"atomic","title":"Atomic","index":"4"}],"reading_time":"1316 words in 9 min"}