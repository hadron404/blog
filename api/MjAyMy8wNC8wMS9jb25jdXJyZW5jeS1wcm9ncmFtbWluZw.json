{"title":"并发编程","date":"2023-04-01T20:37:01.000Z","date_formatted":{"ll":"Apr 1, 2023","L":"04/01/2023","MM-DD":"04-01"},"link":"2023/04/01/concurrency-programming","tags":["concurrency"],"categories":["concurrency-programming"],"updated":"2023-04-13T15:08:34.440Z","content":"<h2 id=\"并发（concurrency）与并行（parallel）\">并发（Concurrency）与并行（parallel）<a title=\"#并发（concurrency）与并行（parallel）\" href=\"#并发（concurrency）与并行（parallel）\"></a></h2>\n<h3 id=\"如何理解或辨别\">如何理解或辨别<a title=\"#如何理解或辨别\" href=\"#如何理解或辨别\"></a></h3>\n<p>（1）Brian Goetz 在其 2016 年的演讲 ”From Concurrent to Parallel“中首次指出该问题，并给出了一个较为合理的区分方法</p>\n<blockquote>\n<ul>\n<li>并发是指如何正确、高效地控制共享资源</li>\n<li>并行是指如何利用更多的资源来产生更快速的响应</li>\n</ul>\n</blockquote>\n<p>（2）从性能的角度辨别</p>\n<blockquote>\n<ul>\n<li>并发：可以同时处理多个任务，即不必等待一个任务完成就能开始处理其他任务。</li>\n<li>并行：同时在多处执行多个任务。</li>\n</ul>\n</blockquote>\n<p>（3）从解决问题的角度</p>\n<blockquote>\n<ul>\n<li>并发：并发解决的是阻塞问题，即一个任务必须要等待非其可控的外部条件满足后才能继续执行。\n<ul>\n<li>最常见的例子是I/O，一个任务必须要等待输入才能执行（即被阻塞），称为 <strong>I/O密集型问题</strong>。</li>\n</ul>\n</li>\n<li>并行：并行解决的是所谓的计算密集型问题，即通过把任务分成多个部分，并在多个处理器上执行，从而提升程序运行的速度。</li>\n</ul>\n</blockquote>\n<p>（4）On Java 8 给出的新定义：</p>\n<blockquote>\n<p>并发是一系列如何减少等待并提升性能的技术。</p>\n</blockquote>\n<h3 id=\"混淆并发与并行的原因\">混淆并发与并行的原因<a title=\"#混淆并发与并行的原因\" href=\"#混淆并发与并行的原因\"></a></h3>\n<ul>\n<li>在<strong>定义</strong>上混淆：都可以处理多个任务</li>\n<li>在<strong>实现机制</strong>上混淆：很多编程语言（包括Java）使用相同的机制 —— 线程 —— 来实现并发和并行</li>\n</ul>\n<h4 id=\"示例：汉堡的制作\">示例：汉堡的制作<a title=\"#示例：汉堡的制作\" href=\"#示例：汉堡的制作\"></a></h4>\n<p>从一个汉堡的制作过程看并发和并行：</p>\n<p>假设一个汉堡的制作过程有三个阶段：提供面包、制作馅料、组合面包和馅料。<br>\n一个制作员制作汉堡的过程： 可以是 依次进行 1，2，3 三个阶段，最后汉堡制作完成， 制作时间是三个阶段的时间的总和。</p>\n<p>并发 的制作就是 1，2，3 三个阶段同时进行，制作时间为三个阶段中最慢的时间。</p>\n<p>并行的制作就是 有多个制作员，分别进行三个阶段。</p>\n<h3 id=\"进一步细分\">进一步细分<a title=\"#进一步细分\" href=\"#进一步细分\"></a></h3>\n<ul>\n<li><strong>纯并发</strong>（purely concurrent）：多个任务在单 CPU 上运行。纯粹并发系统会比时序系统更快地生成结果，但是无法利用多处理器进一步提升性能</li>\n<li><strong>并发式并行</strong>（concurrent-parallel）：应用并发技术，使程序能利用多处理器实现更高的性能</li>\n<li><strong>并行式并发</strong>（parallel-concurrent）：使用并行编程技术编写的程序，而且即便只有一个处理器也能运行（Java 8 的 Stream 就是很好的例子）</li>\n<li><strong>纯并行</strong>（purely parallel）：只能在多处理器上运行</li>\n</ul>\n<h2 id=\"线程（thread）与进程（process）\">线程（Thread）与进程（Process）<a title=\"#线程（thread）与进程（process）\" href=\"#线程（thread）与进程（process）\"></a></h2>\n<h6 id=\"进程\">进程<a title=\"#进程\" href=\"#进程\"></a></h6>\n<p>进程是一个“执行中的程序”，是系统进行资源分配和调度的一个独立单位。</p>\n<h6 id=\"线程\">线程<a title=\"#线程\" href=\"#线程\"></a></h6>\n<p>驱动任务的执行线程（简称 线程），是操作系统进程内部按单一顺序执行的控制流。也被称为轻量级进程。<br>\n一个进程可以拥有多个线程。</p>\n<h3 id=\"线程-1\">线程<a title=\"#线程-1\" href=\"#线程-1\"></a></h3>\n<h4 id=\"使用线程的优势\">使用线程的优势<a title=\"#使用线程的优势\" href=\"#使用线程的优势\"></a></h4>\n<ul>\n<li>建模的简单性</li>\n<li>异步事件的简化处理</li>\n<li>使复杂的异步代码变得更简单</li>\n<li>响应更灵敏的用户界面</li>\n<li>充分发挥多处理器系统的强大计算能力 —— 最简单的方式</li>\n</ul>\n<h4 id=\"线程带来的风险\">线程带来的风险<a title=\"#线程带来的风险\" href=\"#线程带来的风险\"></a></h4>\n<ol>\n<li>安全性问题：<strong>永远不发生糟糕的事情</strong>（在没有充足的同步情况下，多个线程中的操作执行顺序是不可知的）</li>\n<li>活跃性问题：<strong>某件正确的事情最终会发生</strong></li>\n<li>性能问题： <strong>希望正确的事情尽快发生</strong>（感觉是我们使用线程想到的最有益的事情了）</li>\n</ol>\n<h4 id=\"线程池\">线程池<a title=\"#线程池\" href=\"#线程池\"></a></h4>\n<p>顾名思义是线程的池子。其利用了池化技术，将多个线程由一个统一的方式进行管理，包括线程的创建、销毁、执行任务等，而这种方式就是池。<br>\n所以包括了线程的池就称为线程池，与此相关的还有JDBC 连接池，MQ 的连接池等等。</p>\n<h5 id=\"线程池的优势\">线程池的优势<a title=\"#线程池的优势\" href=\"#线程池的优势\"></a></h5>\n<ul>\n<li>降低线程创建和销毁线程造成的开销</li>\n<li>提高响应速度。任务到达时，相对于手工创建一个线程，直接从线程池中拿线程，速度肯定快很多</li>\n<li>提高线程可管理性。线程是稀缺资源，如果无限制地创建，不仅会消耗系统资源，还会降低系统稳定性，使用线程池可以进行统一分配、调优和监控</li>\n</ul>\n<h2 id=\"线程安全性\">线程安全性<a title=\"#线程安全性\" href=\"#线程安全性\"></a></h2>\n<p>最核心的概念就是正确性。</p>\n<p>正确性：某个类的行为与其规范完全一致。</p>\n<p>当多个线程访问某个类时，这个类始终都能表现出正确的行为，那么就称这个类是线程安全的。也可以说这个类具备线程安全性。</p>\n<p>在考虑线程安全性时，要注重于如何防止在数据上发生不受控的访问。</p>\n<h3 id=\"编写线程安全的代码\">编写线程安全的代码<a title=\"#编写线程安全的代码\" href=\"#编写线程安全的代码\"></a></h3>\n<p>编写线程安全的代码核心是对状态访问操作进行管理：</p>\n<ul>\n<li><strong>共享（shared）</strong>：变量可以由多个线程访问。</li>\n<li><strong>可变（mutable）</strong>：变量的值在其生命周期内可以发生变化。</li>\n</ul>\n<p>一个对象是否需要线程安全，取决于 <strong>它是否被多个线程访问</strong>，它是程序访问对象的方式，而不是对象要实现的功能。</p>\n<p>一般通过采用 “同步机制” 来协同对对象可变状态的访问，使得对象是线程安全的。</p>\n<h4 id=\"java-中的同步机制\">Java 中的同步机制<a title=\"#java-中的同步机制\" href=\"#java-中的同步机制\"></a></h4>\n<p>在 Java 中，主要的同步机制即 <code>synchronized</code>，其他的同步还包括</p>\n<ul>\n<li>volatile</li>\n<li>Explicit Lock</li>\n<li>Atomic variable</li>\n</ul>\n","prev":{"title":"Java 并发编程","link":"2023/04/11/java-concurrency-programming-1"},"next":{"title":"认证授权系统设计【三】基于 Spring-Authorization-Server 授权服务器方案实现","link":"2023/03/30/auth-system-design-3"},"plink":"https://hadron404.github.io/blog/2023/04/01/concurrency-programming/","toc":[{"id":"并发（concurrency）与并行（parallel）","title":"并发（Concurrency）与并行（parallel）","index":"1","children":[{"id":"如何理解或辨别","title":"如何理解或辨别","index":"1.1"},{"id":"混淆并发与并行的原因","title":"混淆并发与并行的原因","index":"1.2"},{"id":"进一步细分","title":"进一步细分","index":"1.3"}]},{"id":"线程（thread）与进程（process）","title":"线程（Thread）与进程（Process）","index":"2","children":[{"id":"线程-1","title":"线程","index":"2.1"}]},{"id":"线程安全性","title":"线程安全性","index":"3","children":[{"id":"编写线程安全的代码","title":"编写线程安全的代码","index":"3.1"}]}],"reading_time":"1450 words in 10 min"}